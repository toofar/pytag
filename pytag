#!/usr/bin/env python
import sys, os, eyeD3, re, string, random

LICENSE="The zlib license: http://opensource.org/licenses/Zlib"

todo="""
TODO: Use this regex module for **better unicode handling**: https://pypi.python.org/pypi/regex
TODO: More options in dest for getting substrings etc (handle
graphemes!). So you can do like {filename:s/"//g:}. Or maybe
{title:0:-3:}. And {track:r[0-9][0-9]:}. See around line 332 where the
mods dict is populated.
TODO: When listing tags make it so you can select or filter for certain
tags without having to pipe through grep in a sepearate step.
TODO: Maybe have some mode where you can edit filenames/tags in an editor.
"""

usage="""
Usage:
    pytag file...
    pytag source dest file...
    pytag -f dest file...
    pytag dest file...

    In the first usage just list the tags of file(s). Equivalent to -l.

    In the second and third usage set the tags specified in dest from
    the string specified in source. Passing -f is equivalent to passing
    source as "{filename}".

    In the fourth usage rename the file(s) to the string specified in
    dest.

    The source argument is used to provide a string that dest matches
    against to extract tags from. It can use the python curly-brace
    format string syntax to substitute values into the string.
    Eg "{p1}::{album}::{filename}".
    Valid keys are lower case ID3 tags, when present in the file, along
    with a few extra ones:
        filename  The basename of the file.
        ext       The file extension.
        pdir      The dirname of the absolute path to the file.
        p1        The parent directory of the file.
        p2..N     The Nth parent directory of the file.
    Use the -l argument to see all available ones for a file (except for
    the pN key which are dynamiccaly generated).

    The dest argument is used to set tags from match expressions or to
    rename the file to the specifed string (with the same keys available
    as specifed for source). Additionally to what was described above
    for source you can suffix a keyname with an asterix to specify a
    greedy match (eg "{track*}"). You can also, with the -r flag, pass a
    valid python regex. It can still have curly-brace delimited keys in
    it and name match groups are matched to tags to set.

    There are is is one other transform available in dest right now eg
    "{track^}" (or {track*^} if you want it greedy) will turn all
    underscores to spaces and sentence case tag. Eg.

        like_a_stone_(live)_(bonus_track) => Like a Stone (Live) (Bonus Track)

Examples:

    # Set tags from filename
    pytag -f "{track}. {artist} - {title}.mp3" file

    # Set tags from parent dir, fixed strings and filename
    pytag "{p1}::Big Joe::2013::{filename}" "{album}::{artist}::{year}::{track} {title}_junk.mp3" file

    # Rename file(s) from tags.
    pytag "{track:02} - {artist} - {title}.{ext}" file
"""

import argparse
parser = argparse.ArgumentParser(description=usage,
                                 formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("-d", "--dry-run", action='store_true', help=
                    "Print what would be done, but don't do it.")
parser.add_argument("-f", action='store_true', help=
                    "Use filename as source. Equivalent to "+\
                    "passing \"{filename}\" as the first positional argument.")
parser.add_argument("-r", "--regex", action='store_true', help=
                    "The dest string is a (python) regex. Don't escape it.")
parser.add_argument("-o", "--stdout", action='store_true', help=
                    "Print the transformed source string to stdout. "+\
                    "Don't perform the operation. When renaming a file just "+\
                    "print out the new filename. When setting tags print out "+\
                    "the changed tags in rfc822(-ish) format.")
parser.add_argument("-l", "--list", action='store_true', help=
                    "Just print the tags from the file (plus a couple extra) "+\
                    "in rfc822 format.")
parser.add_argument('-e','--editor', help='Open (expanded) dest string(s) '+
                    'an editor before applying to dest. Default if no source '+
                    'is specified is dest. Default for source and dest if '+
                    'neither are specified is '+
                    """{filename}::{album}::{track}::{artist}::{title}.
                    You can specify arguments to the external program
                    (like sed) with shell quoting. Prefixing the command
                    name with \'-\' will use stdin and stdout otherwise
                    a file to operate on will be passed as the final
                    argument.""",
                    metavar='myeditor', nargs='?', default='default')
parser.add_argument("source", nargs='?')
parser.add_argument("dest", nargs='?')
parser.add_argument("file", nargs='*', help="The file(s) to operate on.")
args = parser.parse_args()

stdout=args.stdout # Kinda like dry run but more machine usable?
dry_run=args.dry_run
input_is_regex=args.regex
list_tags=args.list
fnames=[]
source=""
if args.f:
    source = "{filename}"
dest=""

EDITOR=os.environ.get('EDITOR','editor')
if args.editor != 'default':
    if args.editor:
        if os.path.splitext(args.editor)[1] or len(args.editor.split()) > 1:
            print >>sys.stderr, ("Warning: The value of --editor doesn't "
                                 "look like an executable, try using '--' "
                                 "to seperate positional arguments from "
                                 "options" )
        EDITOR = args.editor
    import tempfile
    editf=tempfile.NamedTemporaryFile(delete=False, suffix='.pytag')
else:
    editf=None
pos_args = filter(bool, [args.source, args.dest]+args.file)

for arg in pos_args:
    if os.path.isfile(arg):
        fnames.extend([arg])
        continue
    if fnames:
        print >>sys.stderr, "Warning: Couldn't find file '%s'" % arg
    else:
        if not source:
            source=arg
        elif not dest:
            dest=arg
        else:
            print >>sys.stderr, "Warning: Couldn't find file '%s'" % arg
            print >>sys.stderr, "Warning: Or too many non-file positional arguments."
if editf and not source:
    source="{filename}::{album}::{track}::{artist}::{title}"
if editf and not dest:
    dest=source

if not fnames:
    print >>sys.stderr, "Fatal: Nothing to do."
    sys.exit(1)

# Automatically generates some values that can be used in the `dest`
# format string.
# Currently just gets the path segments p1, p2 etc from `pdir` as
# needed.
class DynDict(dict):
    def get(self, key, default=None):
        try:
            ret = self.__getitem__(key)
            if isinstance(ret, str):
                return unicode(ret)
            else:
                return ret
        except:
            return default
    def __getitem__(self, key):
        try:
            if key.startswith('p') and int(key[1:]):
                l=int(key[1:])-1
                p=dict.__getitem__(self,"pdir")
                while l>0:
                    p=os.path.split(p)[0]
                    l=l-1
                return os.path.split(p)[1]
            if key.startswith('junk') and int(key[4:]):
                return None
        except:
            pass
        return dict.__getitem__(self,key)

def tags_from_file(f):
    # TODO: Can actually have multiple comments etc. See tagToRrc822 in
    # eyeD3.tag.__file__
    #eyeD3.tag.tagToRfc822(eyeD3.tag.Mp3AudioFile(f))

    source_d=DynDict()

    # Some non-tags that can be used in the `dest` format string.
    source_d['filename'] = os.path.basename(f)
    source_d['pdir'] = os.path.abspath(os.path.dirname(f))
    source_d['ext'] = os.path.splitext(f)[1].lstrip('.')

    tag = eyeD3.Tag()
    try:
        if not tag.link(f):
            return source_d
    except eyeD3.tag.TagException, e:
        return source_d

    gfuncs=[]
    for t in dir(tag):
        if t.startswith("get"): gfuncs.extend([t])

    for t in gfuncs:
        try:
            ret = getattr(tag, t)()
            if isinstance(ret, basestring):
                source_d[t[3:].lower()] = getattr(tag, t)()
        except:
            continue
    if not source_d.get("track"):
        source_d['track'] = tag.getTrackNum()[0]
    if not source_d.get("genre"):
        try:
            source_d['genre'] = tag.getGenre().getName()
        except:
            pass
    return source_d

def tags_to_file(tags, f):
    # Doesn't support comment and ...
    if not tags or not f: return
    tag = eyeD3.Tag()
    try:
        if not tag.link(f):
            # New tag. ED3_ANY_VERSION defaults to ID3_DEFAULT_VERSION set in
            # eyeD3.__init__.py to ID3_V2_4. Presumably it will track the
            # newest/recommended version.
            tag = eyeD3.Tag(f)
            tag.header.setVersion(eyeD3.ID3_ANY_VERSION)
    except eyeD3.tag.TagException, e:
        tag = eyeD3.Tag(f)
        tag.header.setVersion(eyeD3.ID3_ANY_VERSION)
    gfuncs={}
    for t in dir(tag):
        if t.startswith("set"):
            gfuncs[t[3:].lower()] = getattr(tag, t)

    if not gfuncs.get("track"):
        gfuncs['track'] = lambda x: tag.setTrackNum((x, tag.getTrackNum()[1]))
    if not gfuncs.get("year"):
        gfuncs['year'] = tag.setDate
    if not gfuncs.get("comment"):
        gfuncs['comment'] = tag.addComment
    if not gfuncs.get("filename"):
        def myrename(newname):
            if not newname:
                os.unlink(tag.linkedFile.name)
            else:
                dirname = os.path.dirname(tag.linkedFile.name)
                if not dirname: dirname = '.'
                newpath = dirname + os.sep + newname
                ext = os.path.splitext(f)[1].lstrip('.')
                if tag.linkedFile.name[-len(ext):] != ext:
                    newpath += ext
                os.rename(tag.linkedFile.name, newpath)
                tag.linkedFile.name = newpath
        tag.myrename = myrename
        gfuncs['filename'] = tag.myrename

    for t in tags.keys():
        if gfuncs.get(t):
            if t == 'genre':
                # Genre only accepts str instead of basestring ...
                tags[t] = str(tags[t])
            gfuncs.get(t)(tags[t])
        else:
            print >>sys.stderr, "Warning: Don't know how to set tag '%s'" % t

    try:
        tag.setVersion(eyeD3.ID3_V2_4)
        tag.setTextEncoding(eyeD3.UTF_8_ENCODING)
        tag.update()
    except eyeD3.tag.TagException, e:
        print >>sys.stderr, "Couldn't update file "+f
        print >>sys.stderr, e
    except UnicodeEncodeError, e:
        print >>sys.stderr, "Couldn't update file "+f
        print >>sys.stderr, e


# Python string.format() style syntax to non-greedy regexp with named capture
# groups. Crazy regex replace is so that {{ doesn't get converted
# (twice) when we are just looking for a single {.
#   s/{/(?P</g
#   s/*}/>.*)/g
#   s/}/>.*?)>/g
# Regex from: http://stackoverflow.com/questions/17644300/replacing-only-single-instances-of-a-character-with-python-regexp
def format_to_re(format):
    if input_is_regex:
        f = re.sub('(?<!\{)\{(?!\{)', '(?P<', format, re.UNICODE)
        f = re.sub('(?<!\})\*\}(?!\})', '>.*)', f, re.UNICODE)
        f = re.sub('(?<!\})\}(?!\})', '>.*?)', f, re.UNICODE)
    else:
        f = re.sub('(?<!\\\{)\\\{(?!\\\{)', '(?P<', re.escape(format),
                   re.UNICODE)
        f = re.sub('(?<!\\\})\\\\\*\\\}(?!\\\})', '>.*)', f, re.UNICODE)
        f = re.sub('(?<!\\\})\\\}(?!\\\})', '>.*?)', f, re.UNICODE)
        f = "^"+f+"$" #only necessary when form is something like "{year}"?
    return f

# Format can be a regexp, optionally with '{key}' blocks in it which will be
# turned into '(?P<key?.*?)'
# Returns a dict with the matches
def tags_from_string(fmt, src_s):
    reg = format_to_re(fmt)
    try:
        return re.search(reg, src_s, re.UNICODE).groupdict()
    except AttributeError:
        return {}

# Sentance case s. exceptions are the words not to capitalise, by default the
# articles.
# TODO: This can be as complex as you like:
#    http://forums.mp3tag.de/index.php?showtopic=13185&hl=grammartron
# Wiki says: http://en.wikipedia.org/wiki/Letter_case#Headings_and_publication_titles
# http://musicbrainz.org/doc/Style/Language/English
# http://grammar.about.com/od/tz/g/Title-Case.htm
def title_except(s, exceptions=['ve', 're', 'll', 'd', 's', 't', 'm', 'a', 'n', 'an', 'of', 'the', 'is', 'and', 'de']):
    s = s.strip()
    s = re.sub(r'\s+', ' ', s, re.UNICODE)

    # Pull the word seperators out of the word list
    seps = re.findall(r'\W+', s, re.UNICODE)
    word_list = re.findall(r'\w+', s, re.UNICODE)

    # Always capitalise the first letter.
    final = [word_list[0].capitalize()]
    for word in word_list[1:]:
       final.append(word.lower() in exceptions and word.lower() or word.capitalize())

    # Make zip happy if there was not a word boundary on the end of the string.
    if len(word_list) > len(seps):
        seps += ['']
    return "".join(sum(zip(final, seps), ()))

def uppercase(s):
    # use re.sub(..., " ", s) if we need to replace more chars
    return title_except(s.replace("_"," ", re.UNICODE))

# This is to bypass the unpacking that happens with string.format
def str_fmt(fmt, kwargs):
    return string.Formatter().vformat(unicode(fmt.decode('utf-8')), None, kwargs)

def set_output_encoding(encoding='utf-8'):
    import sys
    import codecs
    '''When piping to the terminal, python knows the encoding needed, and
       sets it automatically. But when piping to another program (for example,
       | less), python can not check the output encoding. In that case, it
       is None. What I am doing here is to catch this situation for both
       stdout and stderr and force the encoding'''
    current = sys.stdout.encoding
    if current is None :
        sys.stdout = codecs.getwriter(encoding)(sys.stdout)
    current = sys.stderr.encoding
    if current is None :
        sys.stderr = codecs.getwriter(encoding)(sys.stderr)
set_output_encoding()

def rfc822(d):
    for k, v in d.items():
        print "%s: %s" % (k, v)

modifiers = {
    '^' : uppercase,
    'junk' : lambda s : None,
}

# Pull modification directives out of the tag names before passing them
# to re.
# string.Formatter.parse returns an iterator of tuples of each format spec and
# any preceding text. So each block that it parses will look like this
# (all parts are optional of course):
#    "literal text {field_name!conversion:format_spec}"
# So thats the way we put it back together again afterwards too.
# The actual modifications are all performed right before we write the tags
# and/or print to stdout for each file.
# TODO: Maybe modifiers values should be a tuple with a description element?
# TODO: Maybe we should make mods values be able to be a list? I guess you
# could always do it in multiple passes anyway.
new_dest=""
mods={}
for literal_text, field_name, format_spec, conversion in \
        string.Formatter().parse(dest):
    if literal_text is not None:
        new_dest+=literal_text
    if field_name != None:
        if len(field_name.strip()) == 0:
            # re doesn't like empty match groups ...
            field_name="junk%d" % random.randrange(10**4)
            mods[field_name]='junk'
        else:
            m=field_name[-1]
            if m == '^':
                field_name=field_name[0:-1]
                if field_name[-1] in ['*']:
                    mods[field_name[0:-1]]=m
                else:
                    mods[field_name]=m
                #else if ':' in format_spec...
        new_dest+='{'+field_name
        if conversion is not None: new_dest+='!'+conversion
        if format_spec: new_dest+=':'+format_spec
        new_dest+='}'
if new_dest: dest=new_dest

for f in fnames:
    try:
        f=f.decode('utf-8')
    except UnicodeDecodeError:
        sys.stderr.write("Unicode error in filename: ")
        for c in map(ord, f):
            sys.stderr.write("%c" % (c<128 and c or '?'))
        sys.stderr.write("\nTry\n")
        sys.stderr.write("\tfor i in *;do echo \"$i\" | iconv -f"
                         " 'ISO-8859-1' -t 'utf-8' | xargs -d'\n' -n1"
                         " mv \"$i\" ;done\n")
        sys.stderr.write("or use`ls | chardet` to"
                         " guess charset\n")
        continue
    tags=tags_from_file(f)
    if (not source or list_tags or dry_run or stdout) and len(fnames) > 1:
        print
    if not source or list_tags:
        rfc822(tags)
        continue
    if not dest:
        new_f = ""
        try:
            new_f = str_fmt(source, tags)
        except KeyError:
            pass
        if not new_f:
            print >>sys.stderr, "Warning: Couldn't extract all tags in "+\
                    "'%s' from %s" % (source, str(tags))
            print >>sys.stderr, "Warning: Skipping '%s'" % f
            continue
        if stdout:
            print new_f
        else:
            if dry_run:
                print "Renaming file to:", new_f
                continue
            import shutil
            # path.join chokes on non unicode strings. I'm glad someone has
            # handled the conversion for us. Even if it should be a
            # class method.
            ttag=eyeD3.Tag()
            pdir=ttag.strToUnicode(tags['pdir'])
            new_f=ttag.strToUnicode(new_f)
            shutil.move(os.path.join(pdir, ttag.strToUnicode(tags['filename'])),
                        os.path.join(pdir, new_f))
    else:

        ret=""
        try:
            ret = tags_from_string(dest, str_fmt(source, tags))
        except:
            pass
        if not ret:
            try:
                print >>sys.stderr, "Warning: Couldn't extract tags "+\
                "specified in '%s' from '%s'; skipping '%s'." % (
                            dest, str_fmt(source, tags), f)
            except KeyError:
                print >>sys.stderr, "Warning: Couldn't extract tags "+\
                "specified in '%s' from '%s'; skipping '%s'." % (
                            dest, tags, f)
            continue

        if mods:
            for tag, mod in mods.iteritems():
                if mod in modifiers: ret[tag]=modifiers[mod](ret[tag])
            for k, v in list(ret.iteritems()):
                if v == None: del ret[k]

        if stdout:
            rfc822(ret)
        elif editf:
            try:
                editf.write(str_fmt(dest, DynDict(ret)).encode('utf-8'))
                editf.write('\n')
            except KeyError:
                print >>sys.stderr, "Warning: Couldn't extract tags "+\
                "specified in '%s' from '%s'; skipping '%s'." % (
                            dest, tags, f)
                continue
        else:
            if dry_run:
                rfc822(ret)
                continue
            tags_to_file(ret, f)

if editf:
    import subprocess, shlex
    editf.write("#source: ")
    editf.write(source)
    editf.write('\n')
    editf.write("#matches: ")
    editf.write(dest)
    editf.write('\n')
    editf.flush()
    editf.seek(0)

    if EDITOR[0] == '-':
        pipe=True
        EDITOR=shlex.split(EDITOR[1:])
        IN=editf.file
        OUT=subprocess.PIPE
        ERR=sys.stderr
    else:
        pipe = False
        EDITOR=shlex.split(EDITOR)+[editf.name]
        IN=sys.stdin
        OUT=sys.stdout
        ERR=sys.stderr
        editf.close()

    proc = subprocess.Popen(EDITOR,stdin=IN,stdout=OUT,stderr=ERR)
    # not checked, hopefully the file is empty or unchanged?
    retcode = proc.wait()
    dests = []
    if pipe:
        dests = proc.communicate()[0].splitlines()
    else:
        editf = open(editf.name, 'r')
        temp_dests = editf.readlines()
        # Strip trailing commented lines off.
        for i,l in enumerate(reversed(temp_dests)):
            if len(l.strip()) > 0 and l[0] != '#':
                dests = temp_dests[0:-i]
                break
    editf.close()
    if len(dests) == 0:
        print >> sys.stderr, "Empty file, aborting."
        os.unlink(editf.name)
        sys.exit(0)
    # For now assume (check?) there are the same number of lines and that the
    # lines are in the same order. That way we can allow them to change
    # anything and not mind. If they change order or delete some we will need
    # to use heuristics. Although, what does that even mean?
    # * Changing order may be useful whilst editing
    # * Removing would equate to deleting which we support by setting
    #   filename to empty anyway.
    if len(fnames) != len(dests):
        print >>sys.stderr, ("Error: %s: Different number of lines in the "
                "file (%d) than on the command line (%d) aborting." % (
                                                                  editf.name,
                                                                  len(dests),
                                                                  len(fnames)))
        sys.exit(0)
    os.unlink(editf.name)

    for i,f in enumerate(fnames):
        # Currently we are not allowing string formatting being re-inserted in
        # the editor. we could but should refactor the mods stuff into
        # tags_from_string.
        ret=""
        try:
            ret = tags_from_string(dest, dests[i])
        except:
            pass
        if not ret:
            try:
                print >>sys.stderr, "Warning: Couldn't extract tags "+\
                "specified in '%s' from '%s'; skipping '%s'." % (
                            dest, str_fmt(source, tags), f)
            except KeyError:
                print >>sys.stderr, "Warning: Couldn't extract tags "+\
                "specified in '%s' from '%s'; skipping '%s'." % (
                            dest, tags, f)
            continue
        if dry_run:
            rfc822(ret)
            continue
        tags_to_file(ret, f)
