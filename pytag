#!/usr/bin/env python
import sys, os, eyeD3, re

todo="""
TODO: Use this regex module for **better unicode handling**: https://pypi.python.org/pypi/regex
TODO: More options in dest for getting substrings etc (handle
graphemes!). So you can do like {filename:s/"//g:}. Or maybe
{title:0:-3:}.
TODO: When listing tags make it so you can select or filter for certain
tags without having to pipe through grep in a sepearate step.
"""

usage="""
Usage:
    pytag file...
    pytag source dest file...
    pytag -f dest file...
    pytag dest file...

    In the first usage just list the tags of file(s). Equivalent to -l.

    In the second and third usage set the tags specified in dest from
    the string specified in source. Passing -f is equivalent to passing
    source as "{filename}".

    In the fourth usage rename the file(s) to the string specified in
    dest.

    The source argument is used to provide a string that dest matches
    against to extract tags from. It can use the python curly-brace
    format string syntax to substitute values into the string.
    Eg "{p1}::{album}::{filename}".
    Valid keys are lower case ID3 tags, when present in the file, along
    with a few extra ones:
        filename  The basename of the file.
        ext       The file extension.
        pdir      The dirname of the absolute path to the file.
        p1        The parent directory of the file.
        p2..N     The Nth parent directory of the file.
    Use the -l argument to so all available ones for a file (except for
    the pN key which are dynamiccaly generated).

    The dest argument is used to set tags from match expressions or to
    rename the file to the specifed string (with the same keys available
    as specifed for source). Additionally to source you can suffix a
    keyname with an asterix to specify a greedy match (eg "{track*}").
    You can also, with the -r flag, pass a valid python regex. It can
    still have curly-brace delimited keys in it and name match groups
    are matched to tags to set.

Examples:

    # Set tags from filename
    pytag -f "{track}. {artist} - {title}.mp3" file

    # Set tags from parent dir, fixed strings and filename
    pytag "{p1}::Big Joe::2013::{filename}" "{album}::{artist}::{year}::{track} {title}_junk.mp3" file

    # Rename file(s) from tags.
    pytag "{track:02} - {artist} - {title}.{ext}" file
"""

import argparse
parser = argparse.ArgumentParser(description=usage,
                                 formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("-d", "--dry-run", action='store_true', help=
                    "Print what would be done, but don't do it.")
parser.add_argument("-f", action='store_true', help=
                    "Use filename as source. Equivalent to "+\
                    "passing \"{filename}\" as the first positional argument.")
parser.add_argument("-r", "--regex", action='store_true', help=
                    "The dest string is a (python) regex. Don't escape it.")
parser.add_argument("-o", "--stdout", action='store_true', help=
                    "Print the transformed source string to stdout. "+\
                    "Don't perform the operation. When renaming a file just "+\
                    "print out the new filename. When setting tags print out "+\
                    "the changed tags in rfc822(-ish) format.")
parser.add_argument("-l", "--list", action='store_true', help=
                    "Just print the tags from the file (plus a couple extra) "+\
                    "in rfc822 format.")
parser.add_argument("source", nargs='?')
parser.add_argument("dest", nargs='?')
parser.add_argument("file", nargs='*', help="The file(s) to operate on.")
args = parser.parse_args()

stdout=args.stdout # Kinda like dry run but more machine usable?
dry_run=args.dry_run
input_is_regex=args.regex
list_tags=args.list
fnames=[]
source=""
if args.f:
    source = "{filename}"
dest=""
pos_args = filter(bool, [args.source, args.dest]+args.file)

for arg in pos_args:
    if os.path.isfile(arg):
        fnames.extend([arg])
        continue
    if fnames:
        print >>sys.stderr, "Warning: Couldn't find file '%s'" % arg
    else:
        if not source:
            source=arg
        elif not dest:
            dest=arg
        else:
            print >>sys.stderr, "Warning: Couldn't find file '%s'" % arg
            print >>sys.stderr, "Warning: Or too many non-file positional arguments."

if not fnames:
    print >>sys.stderr, "Fatal: Nothing to do."
    sys.exit(1)

# Automatically generates some values that can be used in the `dest`
# format string.
# Currently just gets the path segments p1, p2 etc from `pdir` as
# needed.
class DynDict(dict):
    def get(self, key, default=None):
        try:
            return self.__getitem__(key)
        except:
            return default
    def __getitem__(self, key):
        try:
            if key.startswith('p') and int(key[1:]):
                l=int(key[1:])-1
                p=dict.__getitem__(self,"pdir")
                while l>0:
                    p=os.path.split(p)[0]
                    l=l-1
                return os.path.split(p)[1]
        except:
            pass
        return dict.__getitem__(self,key)

def tags_from_file(f):
    # TODO: Can actually have multiple comments etc. See tagToRrc822 in
    # eyeD3.tag.__file__
    #eyeD3.tag.tagToRfc822(eyeD3.tag.Mp3AudioFile(f))

    source_d=DynDict()

    # Some non-tags that can be used in the `dest` format string.
    source_d['filename'] = os.path.basename(f)
    source_d['pdir'] = os.path.abspath(os.path.dirname(f))
    source_d['ext'] = os.path.splitext(f)[1].lstrip('.')

    tag = eyeD3.Tag()
    if not tag.link(f):
        return source_d

    gfuncs=[]
    for t in dir(tag):
        if t.startswith("get"): gfuncs.extend([t])

    for t in gfuncs:
        try:
            ret = getattr(tag, t)()
            if isinstance(ret, basestring):
                source_d[t[3:].lower()] = getattr(tag, t)()
        except:
            continue
    if not source_d.get("track"):
        source_d['track'] = tag.getTrackNum()[0]
    if not source_d.get("genre"):
        try:
            source_d['genre'] = tag.getGenre().getName()
        except:
            pass
    return source_d

def tags_to_file(tags, f):
    # Doesn't support comment and ...
    if not tags or not f: return
    tag = eyeD3.Tag()
    if not tag.link(f):
        # New tag. ED3_ANY_VERSION defaults to ID3_DEFAULT_VERSION set in
        # eyeD3.__init__.py to ID3_V2_4. Presumably it will track the
        # newest/recommended version.
        tag = eyeD3.Tag(f)
        tag.header.setVersion(eyeD3.ID3_ANY_VERSION)
    gfuncs={}
    for t in dir(tag):
        if t.startswith("set"):
            gfuncs[t[3:].lower()] = getattr(tag, t)

    if not gfuncs.get("track"):
        gfuncs['track'] = lambda x: tag.setTrackNum((x, tag.getTrackNum()[1]))
    if not gfuncs.get("year"):
        gfuncs['year'] = tag.setDate

    for t in tags.keys():
        if gfuncs.get(t):
            gfuncs.get(t)(tags[t])
        else:
            print >>sys.stdeer, "Error: Don't know how to set tag '%s'" % t

    tag.update()


# Python string.format() style syntax to non-greedy regexp with named capture
# groups. Crazy regex replace is so that {{ doesn't get converted
# (twice) when we are just looking for a single {.
#   s/{/(?P</g
#   s/*}/>.*)/g
#   s/}/>.*?)>/g
# Regex from: http://stackoverflow.com/questions/17644300/replacing-only-single-instances-of-a-character-with-python-regexp
def format_to_re(format):
    if input_is_regex:
        f = re.sub('(?<!\{)\{(?!\{)', '(?P<', format)
        f = re.sub('(?<!\})\*\}(?!\})', '>.*)', f)
        f = re.sub('(?<!\})\}(?!\})', '>.*?)', f)
    else:
        f = re.sub('(?<!\\\{)\\\{(?!\\\{)', '(?P<', re.escape(format))
        f = re.sub('(?<!\\\})\\\\\*\\\}(?!\\\})', '>.*)', f)
        f = re.sub('(?<!\\\})\\\}(?!\\\})', '>.*?)', f)
    return f

# Format can be a regexp, optionally with '{key}' blocks in it which will be
# turned into '(?P<key?.*?)'
# Returns a dict with the matches
def tags_from_string(fmt, src_s):
    reg = format_to_re(fmt)
    try:
        return re.search(reg, src_s).groupdict()
    except AttributeError:
        return {}

# This is to bypass the unpacking that happens with string.format
def str_fmt(fmt, kwargs):
    import string
    return string.Formatter().vformat(fmt, None, kwargs)

def rfc822(d):
    for k, v in d.items():
        print "%s: %s" % (k, v)

for f in fnames:
    tags=tags_from_file(f)
    if (not source or list_tags or dry_run or stdout) and len(fnames) > 1:
        print
    if not source or list_tags:
        rfc822(tags)
        continue
    if not dest:
        new_f = ""
        try:
            new_f = str_fmt(source, tags)
        except KeyError:
            pass
        if not new_f:
            print >>sys.stderr, "Warning: Couldn't extract all tags in "+\
                    "'%s' from %s" % (source, str(tags))
            print >>sys.stderr, "Warning: Skipping '%s'" % f
            continue
        if stdout:
            print new_f
        else:
            if dry_run:
                print "Renaming file to:", new_f
                sys.exit(0)
            import shutil
            # path.join chokes on non unicode strings. I'm glad someone has
            # handled the conversion for us. Even if it should be a
            # class method.
            ttag=eyeD3.Tag()
            pdir=ttag.strToUnicode(tags['pdir'])
            new_f=ttag.strToUnicode(new_f)
            shutil.move(os.path.join(pdir, ttag.strToUnicode(tags['filename'])),
                        os.path.join(pdir, new_f))
    else:
        ret = tags_from_string(dest, str_fmt(source, tags))
        if not ret:
            print >>sys.stderr, "Warning: Couldn't extract tags specified "+\
                    "in '%s' from '%s'; skipping '%s'." % (
                        dest, str_fmt(source, tags), f)
            continue
        if stdout:
            rfc822(ret)
        else:
            if dry_run:
                rfc822(ret)
                sys.exit(0)
            tags_to_file(ret, f)

